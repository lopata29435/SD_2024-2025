# Zoo Management System

Это консольное приложение для управления зоопарком. Оно позволяет добавлять животных, учитывать их потребление пищи, формировать списки животных для контактного зоопарка и выводить инвентаризацию.

## Основные идеи решения

### Принципы SOLID
1. **Single Responsibility Principle (SRP)**:
   - Каждый класс отвечает за одну задачу.
     - `AppConfig` - конфигуратор приложения
     - `MenuController` - это контроллер, который работает с пользователем и управляет вызовом нужных функций из бизнес логики.
     - `AnimalService` отвечает за бизнес-логику работы с животными.
     - `TablePrinterService` отвечает за логику отрисовки таблиц.
     - `ConsoleService` отвечает за логику работы консоли(отчистка и прочее).
     - `VetService` отвечает за логику работы вет клиники.
     - `ZooRepository` отвечает за хранение данных их добавление и предоставление(позже когда перейдем к бд, будет отвечать только за логику работы с ними)
     - `ZooApplication` основной класс приложения
   - Это упрощает поддержку и тестирование кода.

2. **Open/Closed Principle (OCP)**:
   - Классы открыты для расширения, но закрыты для модификации. Например:
     - Для добавления нового животного достаточно создать новый класс и добавить его в `AnimalService`, не изменяя существующий код.

3. **Dependency Inversion Principle (DIP)**:
   - Классы зависят от абстракций, а не от конкретных реализаций. Например:
     - `ConsoleMenu` зависит от интерфейса `AnimalService`, а не от конкретной реализации.

### Структура проекта
- **`model`**: Классы, представляющие сущности (животные, вещи).
- **`service`**: Бизнес-логика и сервисы (работа с животными, отрисовка таблиц).
- **`controller`**: Управление взаимодействием с пользователем (в будущем может быть заменено на веб-контроллеры).
- **`repository`**: Работа с данными (в текущей реализации данные хранятся в памяти).

### Использование Spring
- Для Dependency Injection (DI) используется Spring Framework. Это позволяет легко управлять зависимостями и тестировать компоненты.
- Для тестов использовал JUnit5, Mockito и Assertj.
### Общие слова
- Юнит тесты были написаны только туда, где это имеет смысл. Не будем же мы тестить конструктор у макаки :/ Однако,  я написал спопрный юнит тест для TablePrinterService. Спорный он потому что мы проверяем вывод в консоль и это надо проверять другими видами тестов, но я решил попробовать из интереса. Поэтому если вдруг у вас этот тест не прошел, прошу сообщить и просто его закомментить. Также были пропущены тесты для некоторых классов, т.к для них надо писать интеграционные тесты, а не юнит тесты, но если вы не согласны буду раз узнать почему именно вы считаете что тут подходят юнит тесты. 

- На Java только учусь писать, поэтому строго не судите пж, допускаю крайне тупые решения :)

- Всех люблю и буду рад максимально строгой, бъективной и объемной критике, оценка слабо волнует, хочется знаний

## Инструкция по запуску
Вообще я специально добавил уже сбилженный проект и он лежит в папке app/build/libs/app.jar. Лучше всего запускать именно его через Java, т.к консоль внтури ide может некорректно работать + gradle может криво запустить и приложение будет сваливаться. Но если хотите заморочиться и проверить билд и.т.д то вот инструкция:

### Требования
- Java 21
- Gradle 8.12.1

### Запуск через Gradle
1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/lopata29435/SD_2024-2025.git
   ```

2. Перейдите в ваш проект:
    ```bash
    cd SD_2024-2025
    ```

3. Прогоните тесты:
    ```bash
    gradle test
    ```

4. Соберите и запустите проект:
    ```bash
    gradle build
    java -jar app/build/libs/app.jar
    #gradle run настоятельно не рекомендую использовать
     ```



